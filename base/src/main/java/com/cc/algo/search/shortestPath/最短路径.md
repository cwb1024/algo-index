最短路径算法是图论中的经典问题之一，用于寻找图中两个顶点之间的最短路径。常见的最短路径算法包括：

1.Dijkstra算法：用于解决单源最短路径问题，即从图中的一个顶点出发，求解到其他所有顶点的最短路径。Dijkstra算法采用贪心策略，逐步确定从起始顶点到其他顶点的最短路径，确保每次迭代都选择距离起始顶点最近的未访问顶点，并通过更新距离数组来实现。

在这个示例中，我们定义了一个DijkstraAlgorithm类，其中包含了实现Dijkstra算法的方法dijkstra。该方法接受一个加权邻接矩阵和源节点的索引，并返回一个包含从源节点到每个节点的最短距离的数组。然后，在main方法中，我们创建了一个示例图，并使用源节点0调用dijkstra方法来计算最短路径。

2.Bellman-Ford算法：用于解决单源最短路径问题，与Dijkstra算法不同的是，Bellman-Ford算法可以处理带有负权边的图。它通过对所有边进行松弛操作，多次迭代更新距离数组，直到所有边都被松弛。如果在进行V-1次迭代后仍然存在可以松弛的边，则说明图中存在负权环。

在这个示例中，我们定义了一个BellmanFordAlgorithm类，其中包含了实现Bellman-Ford算法的方法bellmanFord。该方法接受一个加权邻接矩阵和源节点的索引，并返回一个包含从源节点到每个节点的最短距离的数组。然后，在main方法中，我们创建了一个示例图，并使用源节点0调用bellmanFord方法来计算最短路径。

3.Floyd-Warshall算法：用于解决全源最短路径问题，即求解图中任意两个顶点之间的最短路径。Floyd-Warshall算法采用动态规划的思想，通过一个二维数组来记录任意两个顶点之间的最短路径长度，并通过三重循环逐步更新最短路径。

---
在这个示例中，
我们定义了一个FloydWarshallAlgorithm类，其中包含了实现Floyd-Warshall算法的方法floydWarshall。
该方法接受一个加权邻接矩阵，并返回一个包含从每个节点到每个节点的最短距离的二维数组。
然后，在main方法中，我们创建了一个示例图，并使用floydWarshall方法来计算所有节点之间的最短路径。
